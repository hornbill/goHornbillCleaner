package main

import (
	"encoding/xml"
	"fmt"
	"strconv"
	"strings"

	"github.com/hornbill/color"
)

//deleteRecords - deletes the records in the array generated by getRecordIDs
func deleteRecords(entity string, records []dataStruct) {

	if configDryRun {
		for _, v := range records {
			id := ""
			description := ""
			if entity == "Requests" {
				id = v.RequestID
				description = "Logged On: " + v.LogDate
				if v.CloseDate != "" && v.CloseDate != "<nil>" {
					description += ", Closed On: " + v.CloseDate
				}
			} else if entity == "Asset" {
				id = v.AssetID
				description = "Asset Name: " + v.AssetName
			}

			espLogger("["+strings.ToUpper(entity)+"] ID:"+id+" "+description, "info")
		}
	} else {
		fmt.Println("Deleting block " + strconv.Itoa(currentBlock) + " of " + strconv.Itoa(totalBlocks) + " blocks of records from " + entity + " entity. Please wait...")
		if entity == "Requests" {
			//Go through requests, and delete any associated records
			for _, callRef := range records {

				//-- System Timers
				sysTimerIDs := getSystemTimerIDs(callRef.RequestID)
				if len(sysTimerIDs) != 0 {
					for _, timerID := range sysTimerIDs {
						if timerID.TimerID != "<nil>" && timerID.TimerID != "" {
							deleteTimer(timerID.TimerID)
						}
					}
				}
				//-- Spawned workflow
				requestWorkflow := getRequestWorkflow(callRef.RequestID)
				if requestWorkflow != "<nil>" && requestWorkflow != "" {
					deleteWorkflow(requestWorkflow)
				}

				//-- Request Tasks
				requestTasks := getRequestTasks(callRef.RequestID)
				for _, stateMap := range requestTasks {
					for _, taskMap := range stateMap {
						deleteTask(taskMap.TaskID)
					}
				}

				//-- Asset Associations
				requestAssets := getRequestAssetLinks(callRef.RequestID)
				for _, linkID := range requestAssets {
					if linkID.AssetLinkID != "<nil>" && linkID.AssetLinkID != "" {
						deleteAssetLink(linkID.AssetLinkID)
					}
				}

				//Board Manager Cards
				if boardManagerInstalled {
					requestCards := getRequestCards(callRef.RequestID)
					for _, cardID := range requestCards {
						if cardID.CardID != "<nil>" && cardID.CardID != "" {
							deleteCard(cardID.CardID)
						}
					}
				}

			}
		}
		//Now delete the block of records
		espXmlmc.SetParam("application", "com.hornbill.servicemanager")
		espXmlmc.SetParam("entity", entity)
		var idsToDelete []string
		for _, v := range records {
			id := ""
			if entity == "Requests" {
				id = v.RequestID
			} else if entity == "Assets" {
				id = v.AssetID
			}
			idsToDelete = append(idsToDelete, id)
			espXmlmc.SetParam("keyValue", id)
		}
		deleted, err := espXmlmc.Invoke("data", "entityDeleteRecord")
		if err != nil {
			espLogger("Delete Records failed for entity ["+entity+"], block "+strconv.Itoa(currentBlock), "error")
			color.Red("Delete Records failed for entity [" + entity + "], block " + strconv.Itoa(currentBlock))
			return
		}
		var xmlRespon xmlmcResponse
		err = xml.Unmarshal([]byte(deleted), &xmlRespon)
		if err != nil {
			espLogger("Delete Records response unmarshall failed for entity ["+entity+"], block "+strconv.Itoa(currentBlock), "error")
			color.Red("Delete Records response unmarshall failed for entity [" + entity + "], block " + strconv.Itoa(currentBlock))
			return
		}
		if xmlRespon.MethodResult != "ok" {
			espLogger("entityDeleteRecords was unsuccessful for entity ["+entity+"]: "+xmlRespon.State.ErrorRet, "error")
			color.Red("Could not delete records from " + entity + " entity: " + xmlRespon.State.ErrorRet)
			return
		}
		for _, val := range idsToDelete {
			espLogger("["+strings.ToUpper(entity)+"] ID:"+val+" deleted", "notice")
		}
		color.Green("Block " + strconv.Itoa(currentBlock) + " of " + strconv.Itoa(totalBlocks) + " deleted.")
	}

	currentBlock++
	return
}

func deleteUser(strUser string) {
	//Now delete the user
	espXmlmc.SetParam("userId", strUser)

	deleted, err := espXmlmc.Invoke("admin", "userDelete")
	if err != nil {
		espLogger("Delete Records failed for user ["+strUser+"]", "error")
		color.Red("Delete Records failed for user [" + strUser + "]")
		return
	}
	var xmlRespon xmlmcResponse
	err = xml.Unmarshal([]byte(deleted), &xmlRespon)
	if err != nil {
		espLogger("Delete Records response unmarshall failed for user ["+strUser+"]", "error")
		color.Red("Delete Records response unmarshall failed for user [" + strUser + "]")
		return
	}
	if xmlRespon.MethodResult != "ok" {
		espLogger("entityDeleteRecords was unsuccessful for user ["+strUser+"]: "+xmlRespon.State.ErrorRet, "error")
		color.Red("Could not delete user [" + strUser + "]: " + xmlRespon.State.ErrorRet)
		return
	}
	espLogger("User ["+strUser+"] deleted.", "debug")
	color.Green("User [" + strUser + "] deleted.")
	return
}

//deleteTimer - Takes a System Timer ID, sends it to time::timerDelete API for safe deletion
func deleteTimer(timerID string) {
	espXmlmc.SetParam("timerId", timerID)
	browse, err := espXmlmc.Invoke("time", "timerDelete")
	if err != nil {
		espLogger("Deletion of System Timer failed ["+timerID+"]", "error")
		color.Red("Deletion of System Timer failed [" + timerID + "]")
		return
	}
	var xmlRespon xmlmcResponse
	err = xml.Unmarshal([]byte(browse), &xmlRespon)
	if err != nil {
		espLogger("Unmarshal of response to deletion of System Timer failed ["+timerID+"]", "error")
		color.Red("Unmarshal of response to deletion of System Timer failed [" + timerID + "]")
		return
	}
	if xmlRespon.MethodResult != "ok" {
		espLogger("API Call to delete System Timer failed ["+timerID+"] "+xmlRespon.State.ErrorRet, "error")
		color.Red("API Call to delete System Timer failed [" + timerID + "] " + xmlRespon.State.ErrorRet)
		return
	}
	espLogger("Timer instance sucessfully deleted ["+timerID+"] ", "debug")
}

//deleteTask - Takes a Task ID, sends it to task::taskDelete API for safe deletion
func deleteTask(taskID string) {
	espXmlmc.SetParam("taskId", taskID)
	browse, err := espXmlmc.Invoke("task", "taskDelete")
	if err != nil {
		espLogger("Deletion of Task failed ["+taskID+"]", "error")
		color.Red("Deletion of Task failed [" + taskID + "]")
		return
	}
	var xmlRespon xmlmcResponse
	err = xml.Unmarshal([]byte(browse), &xmlRespon)
	if err != nil {
		espLogger("Unmarshal of response to deletion of Task failed ["+taskID+"]", "error")
		color.Red("Unmarshal of response to deletion of Task failed [" + taskID + "]")
		return
	}
	if xmlRespon.MethodResult != "ok" {
		espLogger("API Call to delete Task failed ["+taskID+"] "+xmlRespon.State.ErrorRet, "error")
		color.Red("API Call to delete Task failed [" + taskID + "] " + xmlRespon.State.ErrorRet)
		return
	}
	espLogger("Task instance sucessfully deleted ["+taskID+"] ", "debug")
}

//deleteWorkflow - Takes a Workflow ID, sends it to bpm::processDelete API for safe deletion
func deleteWorkflow(workflowID string) {
	espXmlmc.SetParam("identifier", workflowID)
	browse, err := espXmlmc.Invoke("bpm", "processDelete")
	if err != nil {
		espLogger("Deletion of Workflow failed ["+workflowID+"]", "error")
		color.Red("Deletion of Workflow failed [" + workflowID + "]")
		return
	}
	var xmlRespon xmlmcResponse
	err = xml.Unmarshal([]byte(browse), &xmlRespon)
	if err != nil {
		espLogger("Unmarshal of response to deletion of Workflow failed ["+workflowID+"]", "error")
		color.Red("Unmarshal of response to deletion of Workflow failed [" + workflowID + "]")
		return
	}
	if xmlRespon.MethodResult != "ok" {
		espLogger("API Call to delete Workflow failed ["+workflowID+"] "+xmlRespon.State.ErrorRet, "error")
		color.Red("API Call to delete Workflow failed [" + workflowID + "] " + xmlRespon.State.ErrorRet)
		return
	}
	espLogger("Workflow instance sucessfully deleted ["+workflowID+"] ", "debug")
}

//deleteAssetLink - Takes a Link PK ID, sends it to data::entityDelete API for safe deletion
func deleteAssetLink(linkID string) {
	espXmlmc.SetParam("application", "com.hornbill.servicemanager")
	espXmlmc.SetParam("entity", "AssetsLinks")
	espXmlmc.SetParam("keyValue", linkID)
	espXmlmc.SetParam("preserveOneToOneData", "false")
	espXmlmc.SetParam("preserveOneToManyData", "false")
	browse, err := espXmlmc.Invoke("data", "entityDeleteRecord")
	if err != nil {
		espLogger("Deletion of Asset Link failed ["+linkID+"]", "error")
		color.Red("Deletion of Asset Link failed [" + linkID + "]")
		return
	}
	var xmlRespon xmlmcResponse
	err = xml.Unmarshal([]byte(browse), &xmlRespon)
	if err != nil {
		espLogger("Unmarshal of response to deletion of Asset Link failed ["+linkID+"]", "error")
		color.Red("Unmarshal of response to deletion of Asset Link failed [" + linkID + "]")
		return
	}
	if xmlRespon.MethodResult != "ok" {
		espLogger("API Call to delete Asset Link failed ["+linkID+"] "+xmlRespon.State.ErrorRet, "error")
		color.Red("API Call to delete Asset Link failed [" + linkID + "] " + xmlRespon.State.ErrorRet)
		return
	}
	espLogger("Asset Link sucessfully deleted ["+linkID+"] ", "debug")
}

//deleteCard - Takes a Card PK ID, sends it to data::entityDelete API for safe deletion
func deleteCard(cardID string) {
	espXmlmc.SetParam("h_card_id", cardID)
	espXmlmc.SetParam("hardDelete", "true")
	browse, err := espXmlmc.Invoke("apps/com.hornbill.boardmanager/Card", "removeCard")
	if err != nil {
		espLogger("Deletion of Card failed ["+cardID+"]", "error")
		color.Red("Deletion of Card failed [" + cardID + "]")
		return
	}
	var xmlRespon xmlmcResponse
	err = xml.Unmarshal([]byte(browse), &xmlRespon)
	if err != nil {
		espLogger("Unmarshal of response to deletion of Card failed ["+cardID+"]", "error")
		color.Red("Unmarshal of response to deletion of Card failed [" + cardID + "]")
		return
	}
	if xmlRespon.MethodResult != "ok" {
		espLogger("API Call to delete Card failed ["+cardID+"] "+xmlRespon.State.ErrorRet, "error")
		color.Red("API Call to delete Card failed [" + cardID + "] " + xmlRespon.State.ErrorRet)
		return
	}
	espLogger("Card sucessfully deleted ["+cardID+"] ", "debug")
}
