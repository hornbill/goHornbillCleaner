package main

import (
	"encoding/xml"
	"fmt"
	"strconv"
	"strings"

	"github.com/fatih/color"
)

// deleteRecords - deletes the records in the array generated by getRecordIDs
func deleteRecords(entity string, records []dataStruct) {
	if configDryRun {
		for _, v := range records {
			id := ""
			description := ""
			if entity == "Requests" {
				id = v.RequestID
				description = "Logged On: " + v.LogDate
				if v.CloseDate != "" && v.CloseDate != "<nil>" {
					description += ", Closed On: " + v.CloseDate
				}
			} else if entity == "Asset" {
				id = v.AssetID
				assetsDeleted = append(assetsDeleted, "urn:sys:entity:com.hornbill.servicemanager:Asset:"+id)
				description = "Asset Name: " + v.AssetName
			} else if entity == "Contact" {
				id = strconv.Itoa(v.ContactID)
				description = "Contact ID: " + id
			} else if entity == "Organizations" {
				id = strconv.Itoa(v.OrgID)
				description = "Organisation ID: " + id
			} else if entity == "ServiceStatusHistory" {
				id = v.HID
				description = "Service Status History ID: " + id
			} else if entity == "Suppliers" {
				id = strconv.Itoa(v.SuppID)
				description = "Supplier ID: " + id
			} else if entity == "AssetsLinks" {
				id = v.AssetID
				description = "Asset Link ID: " + v.AssetLinkID
			} else if entity == "Email" {
				id = strconv.Itoa(v.MessageID)
				description = "; Message Date: " + v.MessageDate
			}
			espLogger("["+strings.ToUpper(entity)+"] ID:"+id+" "+description, "info")
		}
		currentBlock++
		displayBlock++
		return
	}

	fmt.Println("Deleting block " + strconv.Itoa(displayBlock) + " of " + strconv.Itoa(totalBlocks) + " blocks of records from " + entity + " entity. Please wait...")

	if entity == "Requests" {

		if cleanerConf.KeepRequestsCancelBPTasks {

			for _, callRef := range records {
				//-- Spawned workflow
				requestWorkflow := getRequestWorkflow(callRef.RequestID)
				if requestWorkflow != "<nil>" && requestWorkflow != "" {
					deleteWorkflow(requestWorkflow)
				}

				//-- Request Tasks
				requestTasks := getRequestTasks(callRef.RequestID)
				for _, stateMap := range requestTasks {
					for _, taskMap := range stateMap {
						if taskMap.TaskID != "<nil>" && taskMap.TaskID != "" {
							deleteTask(taskMap.TaskID)
						}
					}
				}
			}

		} else {

			//Go through requests, and delete any associated records
			for _, callRef := range records {

				//-- BPM Events
				var bpmQueryParams []queryParamsStruct
				bpmQueryParams = append(bpmQueryParams, queryParamsStruct{Name: "inRequestId", Value: callRef.RequestID})
				bpmTimerIDs := queryExec(appSM, "getRequestBPMEvents", bpmQueryParams)
				if len(bpmTimerIDs) != 0 {
					for _, timerRecord := range bpmTimerIDs {
						if timerRecord.BPMEventID != "<nil>" && timerRecord.BPMEventID != "" {
							deleteEvent(timerRecord.BPMEventID)
						}
						if timerRecord.BPMTimerID != "<nil>" && timerRecord.BPMTimerID != "" {
							deleteTimer(timerRecord.BPMTimerID)
						}
					}
				}

				//-- System Timers
				var stQueryParams []queryParamsStruct
				stQueryParams = append(stQueryParams, queryParamsStruct{Name: "requestId", Value: callRef.RequestID})
				sysTimerIDs := queryExec(appSM, "getRequestSystemTimers", stQueryParams)
				if len(sysTimerIDs) != 0 {
					for _, timerID := range sysTimerIDs {
						if timerID.TimerID != "<nil>" && timerID.TimerID != "" {
							deleteTimer(timerID.TimerID)
						}
					}
				}

				//-- SLM Timer Events
				var slmParams []browseRecordsParamsStruct
				slmParams = append(slmParams, browseRecordsParamsStruct{Column: "h_request_id", Value: callRef.RequestID, MatchType: "exact"})
				slmEventIDs := entityBrowseRecords(appSM, "RequestSLMEvt", "", slmParams)
				if len(slmEventIDs) != 0 {
					for _, eventRecord := range slmEventIDs {
						if eventRecord.BPMEventID != "<nil>" && eventRecord.BPMEventID != "" {
							deleteEvent(eventRecord.BPMEventID)
						}
					}
				}

				//-- Spawned workflow
				requestWorkflow := getRequestWorkflow(callRef.RequestID)
				if requestWorkflow != "<nil>" && requestWorkflow != "" {
					deleteWorkflow(requestWorkflow)
				}

				//-- Request Tasks
				requestTasks := getRequestTasks(callRef.RequestID)
				for _, stateMap := range requestTasks {
					for _, taskMap := range stateMap {
						if taskMap.TaskID != "<nil>" && taskMap.TaskID != "" {
							deleteTask(taskMap.TaskID)
						}
					}
				}

				//-- Asset Associations
				var assetLinksParams []browseRecordsParamsStruct
				callrefURN := "urn:sys:entity:" + appSM + ":Requests:" + callRef.RequestID
				assetLinksParams = append(assetLinksParams, browseRecordsParamsStruct{Column: "h_fk_id_l", Value: callrefURN, MatchType: "exact"})
				assetLinksParams = append(assetLinksParams, browseRecordsParamsStruct{Column: "h_fk_id_r", Value: callrefURN, MatchType: "exact"})
				requestAssets := entityBrowseRecords(appSM, "AssetsLinks", "any", assetLinksParams)
				for _, linkID := range requestAssets {
					if linkID.AssetLinkID != "<nil>" && linkID.AssetLinkID != "" {
						entityDeleteRecords(appSM, "AssetsLinks", []string{linkID.AssetLinkID}, false, false)
					}
				}

				//Board Manager Cards
				if boardManagerInstalled {
					var cardParams []browseRecordsParamsStruct
					cardParams = append(cardParams, browseRecordsParamsStruct{Column: "h_key", Value: callRef.RequestID, MatchType: "exact"})
					requestCards := entityBrowseRecords(appBM, "Card", "", cardParams)
					for _, cardID := range requestCards {
						if cardID.HID != "<nil>" && cardID.HID != "" {
							deleteCard(cardID.HID)
						}
					}
				}

			}
		}
	}

	if entity == "Asset" {
		//Go through assets, delete any associated CM records
		for _, asset := range records {
			//Process Impacts
			var impQueryParams []queryParamsStruct
			impQueryParams = append(impQueryParams, queryParamsStruct{Name: "entityId", Value: asset.AssetID})
			ciImpacts := queryExec(appSM, "getImpactsForExplorer", impQueryParams)
			for _, impact := range ciImpacts {
				if impact.AssetImpactID != "<nil>" && impact.AssetImpactID != "" {
					entityDeleteRecords(appSM, "ConfigurationItemsImpact", []string{impact.AssetImpactID}, false, false)
				}
			}

			//Process Dependencies
			var depQueryParams []queryParamsStruct
			depQueryParams = append(depQueryParams, queryParamsStruct{Name: "entityId", Value: asset.AssetID})
			ciDependencies := queryExec(appSM, "getDependencies", depQueryParams)
			for _, dependency := range ciDependencies {
				if dependency.AssetDependencyID != "<nil>" && dependency.AssetDependencyID != "" {
					entityDeleteRecords(appSM, "ConfigurationItemsDependency", []string{dependency.AssetDependencyID}, false, false)
				}
			}

			//Process Policies
			var polQueryParams []queryParamsStruct
			polQueryParams = append(polQueryParams, queryParamsStruct{Name: "entityId", Value: asset.AssetID})
			ciPolicies := queryExec(appSM, "getItemsInPolicy", polQueryParams)
			for _, dependency := range ciPolicies {
				if dependency.AssetPolicyID != "<nil>" && dependency.AssetPolicyID != "" {
					entityDeleteRecords(appSM, "ConfigurationItemsInPolicy", []string{dependency.AssetPolicyID}, false, false)
				}
			}
		}
	}
	//Now delete the block of records
	var idsToDelete []string
	for _, v := range records {
		id := ""
		if entity == "Requests" {
			if !(cleanerConf.KeepRequestsCancelBPTasks) {
				id = v.RequestID
			}
		} else if entity == "Asset" {
			id = v.AssetID
		} else if entity == "ServiceStatusHistory" {
			id = v.HID
		} else if entity == "Contact" {
			id = strconv.Itoa(v.ContactID)
		} else if entity == "Organizations" {
			id = strconv.Itoa(v.OrgID)
		} else if entity == "Suppliers" {
			id = strconv.Itoa(v.SuppID)
		} else if entity == "SupplierContracts" {
			id = v.SuppConID
		} else if entity == "AssetsLinks" {
			id = v.AssetLinkID
		} else if entity == "Email" {
			id = strconv.Itoa(v.MessageID)
		}
		if id != "" {
			idsToDelete = append(idsToDelete, id)
		}
	}
	if len(idsToDelete) > 0 {
		if entity == "Contact" || entity == "Organizations" {
			entityDeleteRecords(appCore, entity, idsToDelete, false, false)
		} else if entity == "Suppliers" || entity == "SupplierContracts" {
			entityDeleteRecords(appSuppM, entity, idsToDelete, false, false)
		} else if entity == "Email" {
			deleteEmailRecords(idsToDelete)
		} else {
			entityDeleteRecords(appSM, entity, idsToDelete, false, false)
		}
	} else {
		color.Yellow("Nothing to delete in this block.")
	}
	color.Green("Block " + strconv.Itoa(displayBlock) + " of " + strconv.Itoa(totalBlocks) + " deleted.")
	currentBlock++
	displayBlock++
}

func deleteEmailRecords(emailIDs []string) {
	for _, v := range emailIDs {
		espXmlmc.SetParam("messageId", v)
	}
	espXmlmc.SetParam("purge", "true")
	requestXML := espXmlmc.GetParam()
	browse, err := espXmlmc.Invoke("mail", "deleteMessage")
	if err != nil {
		espLogger("mail:deleteMessage:"+err.Error(), "error")
		espLogger(requestXML, "debug")
		color.Red("deleteMessage Invoke failed: " + err.Error())
		return
	}
	var xmlRespon xmlmcResponse
	err = xml.Unmarshal([]byte(strings.Map(printOnly, string(browse))), &xmlRespon)
	if err != nil {
		espLogger("mail:deleteMessage:Unmarshal:"+err.Error(), "error")
		espLogger("Request XML: "+requestXML, "debug")
		espLogger("Response XML: "+browse, "debug")
		color.Red("deleteMessage Unmarshal failed: " + err.Error())
		return
	}
	if xmlRespon.MethodResult != "ok" {
		espLogger("mail:deleteMessage:"+xmlRespon.State.ErrorRet, "error")
		espLogger("Request XML: "+requestXML, "debug")
		espLogger("Response XML: "+browse, "debug")
		color.Red("deleteMessage MethodResult failed for: " + xmlRespon.State.ErrorRet)
		return
	}
	espLogger("Messages deleted: "+strings.Join(emailIDs[:], ","), "notice")
}

func deleteUser(strUser string) {
	//Now delete the user
	espXmlmc.SetParam("userId", strUser)
	requestXML := espXmlmc.GetParam()
	deleted, err := espXmlmc.Invoke("admin", "userDelete")
	if err != nil {
		espLogger("userDelete:Invoke:"+strUser+":"+err.Error(), "error")
		espLogger("Request XML: "+requestXML, "debug")
		color.Red("userDelete Invoke failed for " + strUser + ":" + err.Error())
		return
	}
	var xmlRespon xmlmcResponse
	err = xml.Unmarshal([]byte(strings.Map(printOnly, string(deleted))), &xmlRespon)
	if err != nil {
		espLogger("userDelete:Unmarshal:"+strUser+":"+err.Error(), "error")
		espLogger("Request XML: "+requestXML, "debug")
		espLogger("Response XML: "+deleted, "debug")
		color.Red("userDelete Unmarshal failed for " + strUser + ":" + err.Error())
		return
	}
	if xmlRespon.MethodResult != "ok" {
		espLogger("userDelete:MethodResult:"+strUser+":"+xmlRespon.State.ErrorRet, "error")
		espLogger("Request XML: "+requestXML, "debug")
		espLogger("Response XML: "+deleted, "debug")
		color.Red("userDelete MethodResult failed for " + strUser + ":" + xmlRespon.State.ErrorRet)
		return
	}
	espLogger("User "+strUser+" deleted.", "notice")
}

// deleteTimer - Takes a System Timer ID, sends it to time::timerDelete API for safe deletion
func deleteTimer(timerID string) {
	espXmlmc.SetParam("timerId", timerID)
	requestXML := espXmlmc.GetParam()
	browse, err := espXmlmc.Invoke("time", "timerDelete")
	if err != nil {
		espLogger("timerDelete:Invoke:"+timerID+":"+err.Error(), "error")
		espLogger("Request XML: "+requestXML, "debug")
		color.Red("timerDelete Invoke failed for " + timerID + ":" + err.Error())
		return
	}
	var xmlRespon xmlmcResponse
	err = xml.Unmarshal([]byte(strings.Map(printOnly, string(browse))), &xmlRespon)
	if err != nil {
		espLogger("timerDelete:Unmarshal:"+timerID+":"+err.Error(), "error")
		espLogger("Request XML: "+requestXML, "debug")
		espLogger("Response XML: "+browse, "debug")
		color.Red("timerDelete Unmarshal failed for " + timerID + ":" + err.Error())
		return
	}
	if xmlRespon.MethodResult != "ok" {
		espLogger("timerDelete:MethodResult:"+timerID+":"+xmlRespon.State.ErrorRet, "error")
		espLogger("Request XML: "+requestXML, "debug")
		espLogger("Response XML: "+browse, "debug")
		color.Red("timerDelete MethodResult failed for " + timerID + ":" + xmlRespon.State.ErrorRet)
		return
	}
	espLogger("Timer "+timerID+" deleted", "notice")
}

// deleteEvent - Takes a System Timer Event ID, sends it to time::timerDelete API for safe deletion
func deleteEvent(eventID string) {
	espXmlmc.SetParam("eventId", eventID)
	requestXML := espXmlmc.GetParam()
	browse, err := espXmlmc.Invoke("time", "timerEventDelete")
	if err != nil {
		espLogger("timerEventDelete:Invoke:"+eventID+":"+err.Error(), "error")
		espLogger("Request XML: "+requestXML, "debug")
		color.Red("timerEventDelete Invoke failed for " + eventID + ":" + err.Error())
		return
	}
	var xmlRespon xmlmcResponse
	err = xml.Unmarshal([]byte(strings.Map(printOnly, string(browse))), &xmlRespon)
	if err != nil {
		espLogger("timerEventDelete:Unmarshal:"+eventID+":"+err.Error(), "error")
		espLogger("Request XML: "+requestXML, "debug")
		espLogger("Response XML: "+browse, "debug")
		color.Red("timerEventDelete Unmarshal failed for " + eventID + ":" + err.Error())
		return
	}
	if xmlRespon.MethodResult != "ok" {
		espLogger("timerEventDelete:MethodResult:"+eventID+":"+xmlRespon.State.ErrorRet, "error")
		espLogger("Request XML: "+requestXML, "debug")
		espLogger("Response XML: "+browse, "debug")
		color.Red("timerEventDelete MethodResult failed for " + eventID + ":" + xmlRespon.State.ErrorRet)
		return
	}
	espLogger("Timer Event "+eventID+" deleted", "notice")
}

// deleteTask - Takes a Task ID, sends it to task::taskDelete API for safe deletion
func deleteTask(taskID string) {
	var fie = "taskDelete"
	var ver = "deleted"
	if cleanerConf.KeepRequestsCancelBPTasks {
		fie = "taskCancel"
		ver = "cancelled"
	}
	espXmlmc.SetParam("taskId", taskID)
	requestXML := espXmlmc.GetParam()
	browse, err := espXmlmc.Invoke("task", fie)
	if err != nil {
		espLogger(fie+":Invoke:"+taskID+":"+err.Error(), "error")
		espLogger(requestXML, "debug")
		color.Red(fie + " Invoke failed for " + taskID + ":" + err.Error())
		return
	}
	var xmlRespon xmlmcResponse
	err = xml.Unmarshal([]byte(strings.Map(printOnly, string(browse))), &xmlRespon)
	if err != nil {
		espLogger(fie+":Unmarshal:"+taskID+":"+err.Error(), "error")
		espLogger("Request XML: "+requestXML, "debug")
		espLogger("Response XML: "+browse, "debug")
		color.Red(fie + " Unmarshal failed for " + taskID + ":" + err.Error())
		return
	}
	if xmlRespon.MethodResult != "ok" && xmlRespon.State.ErrorRet != "The task specified is already completed and can not be cancelled" {
		espLogger(fie+":MethodResult:"+taskID+":"+xmlRespon.State.ErrorRet, "error")
		espLogger("Request XML: "+requestXML, "debug")
		espLogger("Response XML: "+browse, "debug")
		espLogger(requestXML, "debug")
		color.Red(fie + " MethodResult failed for " + taskID + ":" + xmlRespon.State.ErrorRet)
		return
	}
	espLogger("Task "+taskID+" "+ver, "notice")
}

// deleteWorkflow - Takes a Workflow ID, sends it to bpm::processDelete API for safe deletion
func deleteWorkflow(workflowID string) {
	var fie = "processDelete"
	var ver = "deleted"
	if cleanerConf.KeepRequestsCancelBPTasks {
		fie = "processCancel"
		ver = "cancelled"
	}
	espXmlmc.SetParam("identifier", workflowID)
	requestXML := espXmlmc.GetParam()
	browse, err := espXmlmc.Invoke("bpm", fie)
	if err != nil {
		espLogger(fie+":Invoke:"+workflowID+":"+err.Error(), "error")
		espLogger(requestXML, "debug")
		color.Red(fie + " Invoke failed for " + workflowID + ":" + err.Error())
		return
	}
	var xmlRespon xmlmcResponse
	err = xml.Unmarshal([]byte(strings.Map(printOnly, string(browse))), &xmlRespon)
	if err != nil {
		espLogger(fie+":Unmarshal:"+workflowID+":"+err.Error(), "error")
		espLogger("Request XML: "+requestXML, "debug")
		espLogger("Response XML: "+browse, "debug")
		color.Red(fie + " Unmarshal failed for " + workflowID + ":" + err.Error())
		return
	}
	if xmlRespon.MethodResult != "ok" {
		espLogger(fie+":MethodResult:"+workflowID+":"+xmlRespon.State.ErrorRet, "error")
		espLogger("Request XML: "+requestXML, "debug")
		espLogger("Response XML: "+browse, "debug")
		color.Red(fie + " MethodResult failed for " + workflowID + ":" + xmlRespon.State.ErrorRet)
		return
	}
	espLogger("Workflow "+workflowID+" "+ver, "notice")
}

// deleteCard - Takes a Card PK ID, sends it to data::entityDelete API for safe deletion
func deleteCard(cardID string) {
	espXmlmc.SetParam("h_card_id", cardID)
	espXmlmc.SetParam("hardDelete", "true")
	requestXML := espXmlmc.GetParam()
	browse, err := espXmlmc.Invoke("apps/"+appBM+"/Card", "removeCard")
	if err != nil {
		espLogger("removeCard:Invoke:"+cardID+":"+err.Error(), "error")
		espLogger(requestXML, "debug")
		color.Red("removeCard Invoke failed for " + cardID + ":" + err.Error())
		return
	}
	var xmlRespon xmlmcResponse
	err = xml.Unmarshal([]byte(strings.Map(printOnly, string(browse))), &xmlRespon)
	if err != nil {
		espLogger("removeCard:Unmarshal:"+cardID+":"+err.Error(), "error")
		espLogger("Request XML: "+requestXML, "debug")
		espLogger("Response XML: "+browse, "debug")
		color.Red("removeCard Unmarshal failed for " + cardID + ":" + err.Error())
		return
	}
	if xmlRespon.MethodResult != "ok" {
		espLogger("removeCard:MethodResult:"+cardID+":"+xmlRespon.State.ErrorRet, "error")
		espLogger("Request XML: "+requestXML, "debug")
		espLogger("Response XML: "+browse, "debug")
		color.Red("removeCard MethodResult failed for " + cardID + ":" + xmlRespon.State.ErrorRet)
		return
	}
	espLogger("Board Manager Card "+cardID+" deleted", "notice")
}

func entityDeleteRecords(application, entity string, keyValues []string, preserveOneToOneData, preserveOneToManyData bool) {
	var deletingKeys []string
	espXmlmc.SetParam("application", application)
	espXmlmc.SetParam("entity", entity)
	for _, keyValue := range keyValues {
		espXmlmc.SetParam("keyValue", keyValue)
		deletingKeys = append(deletingKeys, keyValue)
		if entity == "Asset" {
			assetsDeleted = append(assetsDeleted, "urn:sys:entity:com.hornbill.servicemanager:Asset:"+keyValue)
		}
	}
	logKeys := strings.Join(deletingKeys[:], ";")
	espXmlmc.SetParam("preserveOneToOneData", strconv.FormatBool(preserveOneToOneData))
	espXmlmc.SetParam("preserveOneToManyData", strconv.FormatBool(preserveOneToManyData))
	requestXML := espXmlmc.GetParam()
	browse, err := espXmlmc.Invoke("data", "entityDeleteRecord")
	if err != nil {
		espLogger("entityDeleteRecord:Invoke:"+application+":"+entity+":"+logKeys+":"+err.Error(), "error")
		espLogger(requestXML, "debug")
		color.Red("entityDeleteRecord Invoke failed for " + application + ":" + entity + ":" + logKeys + ":" + err.Error())
		return
	}
	var xmlRespon xmlmcResponse
	err = xml.Unmarshal([]byte(strings.Map(printOnly, string(browse))), &xmlRespon)
	if err != nil {
		espLogger("entityDeleteRecord:Unmarshal:"+application+":"+entity+":"+logKeys+":"+err.Error(), "error")
		espLogger("Request XML: "+requestXML, "debug")
		espLogger("Response XML: "+browse, "debug")
		color.Red("entityDeleteRecord Unmarshal failed for " + application + ":" + entity + ":" + logKeys + ":" + err.Error())
		return
	}
	if xmlRespon.MethodResult != "ok" {
		espLogger("entityDeleteRecord:MethodResult:"+application+":"+entity+":"+logKeys+":"+xmlRespon.State.ErrorRet, "error")
		espLogger("Request XML: "+requestXML, "debug")
		espLogger("Response XML: "+browse, "debug")
		color.Red("entityDeleteRecord MethodResult failed for " + application + ":" + entity + ":" + logKeys + ":" + xmlRespon.State.ErrorRet)
		return
	}
	for _, val := range deletingKeys {
		espLogger(strings.ToUpper(entity)+" "+val+" deleted", "notice")
	}
}

func deleteReport(reportID int) {
	espXmlmc.SetParam("reportId", strconv.Itoa(reportID))
	requestXML := espXmlmc.GetParam()
	browse, err := espXmlmc.Invoke("reporting", "reportDelete")
	if err != nil {
		espLogger("reportDelete:Invoke:"+strconv.Itoa(reportID)+":"+err.Error(), "error")
		espLogger(requestXML, "debug")
		color.Red("reportDelete Invoke failed for " + strconv.Itoa(reportID) + ": " + err.Error())
		return
	}
	var xmlRespon xmlmcResponse
	err = xml.Unmarshal([]byte(strings.Map(printOnly, string(browse))), &xmlRespon)
	if err != nil {
		espLogger("reportDelete:Unmarshal:"+strconv.Itoa(reportID)+":"+err.Error(), "error")
		espLogger("Request XML: "+requestXML, "debug")
		espLogger("Response XML: "+browse, "debug")
		color.Red("reportDelete Unmarshal failed for " + strconv.Itoa(reportID) + ": " + err.Error())
		return
	}
	if xmlRespon.MethodResult != "ok" {
		espLogger("reportDelete:MethodResult:"+strconv.Itoa(reportID)+":"+xmlRespon.State.ErrorRet, "error")
		espLogger("Request XML: "+requestXML, "debug")
		espLogger("Response XML: "+browse, "debug")
		color.Red("reportDelete MethodResult failed for " + strconv.Itoa(reportID) + ": " + xmlRespon.State.ErrorRet)
		return
	}
	espLogger("Report "+strconv.Itoa(reportID)+" deleted", "notice")
	color.Green("Report " + strconv.Itoa(reportID) + " deleted")
}
